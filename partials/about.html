<section class="container">
  <div class="plot">
    <div id="highChart" style="height: 450px; width: 600px"></div>
  </div>
</section>

<section class="container">
    <!-- <button class="btn" ng-click="clearInterval()">Stop</button> -->
  <h5>Select a Frame</h5>
</section>

<section>
  <div class="center">
    <br>
    <div class="frame-group" ng-repeat="frame in frames track by $index">
      <button class="btn frame-btn grey lighten-1" ng-click="setFrame($index)">F{{ $index }}</button>
    </div>
  </div>
  <!-- <video src="data/flickrsearch.webm" autoplay loop width="600" type='video/webm;codecs="vp8, vorbis"'></video> -->
</section>

<section class="container overview">
  <div class="row">
    <div class="col s12 center">
      <h3>K-Means Overview</h3>
      <p><b>In general, K-Means attemps to divide <i>n</i> points into <i>k</i> clusters, where each <i>n<sub>i</sub></i> is assigned to the cluster with the nearest mean. The algorithm will take in <i>k</i> as an argument and return a group of clusters.</b></p>
    </div>
    <div class="col l5 s12">
      <h5>Initialization - Forgy Method</h5>
      <p>A common initialization method, and the one used in this implementation, is the Forgy method. To start, <i>k</i> points are selected at random and used as the starting cluster centers.</p>
    </div>
    <div class="col l7 s12">
      <h5>Clustering - Lloyd's Algorithm</h5>
      <p>
        <b>1. Assignment-</b> Assign each of the <i>n</i> points to the closest mean (cluster center).
        <br>
        <b>2. Update-</b> Compute a new center for each cluster by averaging all of the points assigned to it.
        <br>
        <b>3. Check-</b> If the cluster centers have moved by more than some amount, repeat. If the centers have moved less than some minimum difference, stop.
      </p>
    </div>
    <div class="col s12">
      <h5>Discussion</h5>
      <p>To run the algorithm we have to supply <i>k</i>, the number of clusters, which is a problem since we do not know the optimal value for <i>k</i>. K-Means will always return <i>k</i> clusters, but has no way of telling us if that is the correct number of clusters to fit the data to. One way to counter this, is to run the algorithm for a range of <i>k</i> values and then compute what is known as a <a href="https://en.wikipedia.org/wiki/Silhouette_(clustering)">Silhouette coefficient</a> for each point in each resulting group of clusters. The average of the Silhoutte coefficients of all <i>n</i> points tells us how well the data has been clustered. In the context of extracting colors from images, the users choice of how many colors they want from an image trumps having the optimal number of clusters to fit to the set of pixel data. Still, the input values of <i>k</i> are limited to 3 &le; k &le; 8 since they provide reasonable enough results for most images.
      </p> 

      <p>It is important to keep the assumptions and limitations of any statistical method in mind when working with it. There are several things to watch out for with K-Means besides the set number of clusters as discussed above. Like other data sets, the clusters can be skewed by outliers. It would be nice to run an analogous K-Medians algorithm produce better results. Unfortunately, when using the pixel data this is not possible. R,G,B arrays do not have total order (like numbers do- since they can always be arranged in order from smallest to largest). The lack of natural order for colors prevents us from calculating the median of our clusters, but some advanced methods can still help minimize the effects of outliers. One idea is to use <a href="http://sites.stat.psu.edu/~hlee/PRESENTATION/SAMSI06.pdf">Convex Hull Peeling</a>.

      K-Means is also sensitive to the initial placement of the cluster centers. It is possible for a center to fall into a local minimum which will yeild poor results. Utilizing what is known as a <i>committee machine</i>, where the algorithm is run many times on the same set of data and the results are combined into a single, final answer, provides a nice solution to this problem.</p>
      
    </div>
  </div>
</section>